# Name: Action1_Tenable_Reporting.ps1
# Description: This script will connect to the Tenable Vulnerability Manager API to pull Tenable data in order to correlate the endpoints and vulnerabilities within the Tenable with the Action1 API.  Reports will be created and provided to the user as output or through email.
# Copyright (C) 2024 Action1 Corporation
# Documentation: https://github.com/Action1Corp/Integrations/blob/main/Vulnerability-Managers/Tenable/README.md

# Use Action1 Roadmap system (https://roadmap.action1.com/) to submit feedback or enhancement requests.

# WARNING: Carefully study the provided scripts and components before using them. Test in your non-production lab first.

# LIMITATION OF LIABILITY. IN NO EVENT SHALL ACTION1 OR ITS SUPPLIERS, OR THEIR RESPECTIVE
# OFFICERS, DIRECTORS, EMPLOYEES, OR AGENTS BE LIABLE WITH RESPECT TO THE WEBSITE OR
# THE COMPONENTS OR THE SERVICES UNDER ANY CONTRACT, NEGLIGENCE, TORT, STRICT
# LIABILITY OR OTHER LEGAL OR EQUITABLE THEORY (I)FOR ANY AMOUNT IN THE AGGREGATE IN
# EXCESS OF THE GREATER OF FEES PAID BY YOU THEREFOR OR $100; (II) FOR ANY INDIRECT,
# INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES OF ANY KIND WHATSOEVER; (III) FOR
# DATA LOSS OR COST OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; OR (IV) FOR ANY
# MATTER BEYOND ACTION1'S REASONABLE CONTROL. SOME STATES DO NOT ALLOW THE
# EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE
# LIMITATIONS AND EXCLUSIONS MAY NOT APPLY TO YOU.

param(
    [string] $VulnerabilityManager = "Tenable",

    # --- Tenable Configuration ---
    [string]$TenableAccessKey = '',
    [string]$TenableSecretKey = '',
    [string]$TenableApiBase = "https://cloud.tenable.com",

    # --- Action1 Configuration ---
    [string]$Action1APIKey = '',
    [string]$Action1APISecret = '',
    [string]$Action1OrgID = '',
    [string]$Action1Region = "NorthAmerica",

    # --- Output Directory ---
    [string]$OutputDirectory = "c:\action1",

    
    # --- SMTP / Email Settings ---
    [switch]$SendEmail = $true,
    [string]$SmtpServer = "",
    [int]$SmtpPort = 587,
    [string]$SmtpUser = "",
    [string]$SmtpPassword = "",
    [string]$MailFrom = "",
    [string]$MailTo = "",
    [string]$MailSubject = "Tenable - Action1 Vulnerability Reports",
    [switch]$UseSsl = $true,

    # --- Other Options ---
    [int]$PollInterval = 15,
    [int]$MaxPollMinutes = 30
)

# =====================================================
# FUNCTIONS
# =====================================================

function Write-Log {
    param($Message, $Level = "INFO")
    $ts = (Get-Date).ToString("s")
    Write-Host "[$ts][$Level] $Message"
}

function Show-CVEReport {
    param(
        [string]$Title,
        [array]$CVEList,
        [hashtable]$CVEDetails,
        [string]$OutputDir = "."
    )

    if (-not (Test-Path $OutputDir)) {
        New-Item -ItemType Directory -Force -Path $OutputDir | Out-Null
    }

    Write-Host "`nTotal ${Title}: $($CVEList.Count)"

    if (-not $CVEList -or $CVEList.Count -eq 0) {
        Write-Host "No CVEs found for $Title." -ForegroundColor Yellow
        return
    }

    Write-Host "`n📋 $Title" -ForegroundColor Cyan
    Write-Host "----------------------------------------"

    $reportData = @()
    foreach ($cve in ($CVEList | Sort-Object -Unique)) {
        if ($CVEDetails.ContainsKey($cve)) {
            $info = $CVEDetails[$cve]
            $reportData += [PSCustomObject]@{
                CVE         = $cve
                Severity    = $info.Severity
                Plugin      = $info.PluginName
                Description = if ($info.Description.Length -gt 100) { 
                                  $info.Description.Substring(0, 100) + "..." 
                              } else { 
                                  $info.Description 
                              }
                Solution    = if ($info.Solution.Length -gt 100) { 
                                  $info.Solution.Substring(0, 100) + "..." 
                              } else { 
                                  $info.Solution 
                              }
            }
        }
        else {
            $reportData += [PSCustomObject]@{
                CVE         = $cve
                Severity    = "Unknown"
                Plugin      = "(Not found)"
                Description = "(No description available)"
                Solution    = "(No solution available)"
            }
        }
    }

    $reportData | Sort-Object Severity -Descending | Format-Table -AutoSize

    $reportPath = Join-Path $OutputDir "$($Title.Replace(' ', '_')).csv"
    $reportData | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $reportPath
    if ($script:attachments) { $script:attachments += $reportPath }
    Write-Host "✅ Detailed CVE table exported to $reportPath`n" -ForegroundColor Green
}

function Send-EmailReport {
    param(
        [string]$SmtpServer,
        [int]$SmtpPort,
        [string]$SmtpUser,
        [string]$SmtpPassword,
        [string]$MailFrom,
        [string]$MailTo,
        [string]$MailSubject,
        [string]$MailBody,
        [string[]]$Attachments,
        [switch]$UseSsl
    )

    Write-Log "Preparing email report..."

    try {
        $smtpClient = New-Object System.Net.Mail.SmtpClient($SmtpServer, $SmtpPort)
        $smtpClient.EnableSsl = $UseSsl
        if ($SmtpUser -and $SmtpPassword) {
            $smtpClient.Credentials = New-Object System.Net.NetworkCredential($SmtpUser, $SmtpPassword)
        } else {
            $smtpClient.UseDefaultCredentials = $true
        }

        $mailMessage = New-Object System.Net.Mail.MailMessage
        $mailMessage.From = $MailFrom
        $MailTo.Split(',') | ForEach-Object { $mailMessage.To.Add($_.Trim()) }
        $mailMessage.Subject = $MailSubject
        $mailMessage.Body = $MailBody
        $mailMessage.IsBodyHtml = $false

        foreach ($file in $Attachments) {
            if (Test-Path $file) {
                Write-Log "Attaching file: $file"
                $attachment = New-Object System.Net.Mail.Attachment($file)
                $mailMessage.Attachments.Add($attachment)
            } else {
                Write-Log "Attachment not found: $file" "WARN"
            }
        }

        Write-Log "Sending email to $MailTo via $SmtpServer..."
        $smtpClient.Send($mailMessage)
        Write-Host "📧 Email sent successfully to $MailTo" -ForegroundColor Green
    } catch {
        Write-Host "❌ Failed to send email: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# STEP 0: Validate Output Directory
# =====================================================

if (-not (Test-Path $OutputDirectory)) {
    Write-Log "Creating output directory: $OutputDirectory"
    New-Item -ItemType Directory -Force -Path $OutputDirectory | Out-Null
}

$jsonPath = Join-Path $OutputDirectory "tenable_vuln_export.json"
$csvPath  = Join-Path $OutputDirectory "tenable_vuln_export.csv"

Write-Log "Output will be stored in: $OutputDirectory"
Write-Log "JSON file: $jsonPath"
Write-Log "CSV file:  $csvPath"

# =====================================================
# STEP 1: Export Vulnerabilities from Tenable.io
# =====================================================

$attachments = @()
$Headers = @{
    "X-ApiKeys"  = "accessKey=$TenableAccessKey; secretKey=$TenableSecretKey"
    "Accept"     = "application/json"
    "User-Agent" = "Integration/1.0 (Action1; ScriptIntegration; Build/1.0)"
}

$body = @{
    num_assets = 5000
    include_unlicensed = $false
    filters = @{
        severity = @("LOW", "MEDIUM", "HIGH", "CRITICAL")
    }
} | ConvertTo-Json -Depth 5

$exportUrl = "$TenableApiBase/vulns/export"
Write-Log "Creating Tenable export job..."
try {
    $resp = Invoke-RestMethod -Uri $exportUrl -Method POST -Headers $Headers -Body $body -ContentType "application/json"
    $exportUuid = $resp.export_uuid
    Write-Log "Export job created. UUID: $exportUuid"
} catch {
    Write-Log "Failed to create export job: $($_.Exception.Message)" "ERROR"
    exit 1
}

$statusUrl = "$TenableApiBase/vulns/export/$exportUuid/status"
$elapsed = 0
$readyChunks = @()

Write-Log "Polling Tenable export status..."
while ($true) {
    Start-Sleep -Seconds $PollInterval
    $elapsed += $PollInterval
    try {
        $status = Invoke-RestMethod -Uri $statusUrl -Headers $Headers -Method GET
    } catch {
        Write-Log "Error polling export status: $($_.Exception.Message)" "WARN"
        continue
    }

    if ($status.status -eq "FINISHED" -or $status.chunks_available.Count -gt 0) {
        $readyChunks = $status.chunks_available
        Write-Log "Export ready. Chunks available: $($readyChunks -join ', ')"
        break
    }

    if ($elapsed -ge ($MaxPollMinutes * 60)) {
        Write-Log "Timeout waiting for export." "ERROR"
        exit 1
    }
}

# Download chunks
$allVulns = @()
foreach ($chunk in $readyChunks) {
    $chunkUrl = "$TenableApiBase/vulns/export/$exportUuid/chunks/$chunk"
    Write-Log "Downloading chunk $chunk ..."
    try {
        $chunkData = Invoke-RestMethod -Uri $chunkUrl -Headers $Headers -Method GET
        Write-Log "Downloaded chunk $chunk with $($chunkData.Count) vulns"
        $allVulns += $chunkData
    } catch {
        Write-Log "Failed to download chunk $chunk : $($_.Exception.Message)" "ERROR"
    }
}

if ($allVulns.Count -eq 0) {
    Write-Log "No vulnerabilities returned from Tenable." "WARN"
    exit 0
}

$allVulns | ConvertTo-Json -Depth 10 | Out-File -FilePath $jsonPath -Encoding UTF8
Write-Log "Saved JSON to $jsonPath"

$flat = $allVulns | ForEach-Object {
    [PSCustomObject]@{
        PluginID      = $_.plugin.id
        PluginName    = $_.plugin.name
        cvss3_base_score    = $_.plugin.cvss3_base_score
        cvss3_vector  = $_.plugin.cvss_vector.raw
        Description    = $_.plugin.description
        Severity      = $_.severity
        Synopsis      = $_.plugin.synopsis
        CVE           = if ($_.plugin.cve) { ($_.plugin.cve -join ', ') } else { "" }
        Solution      = $_.plugin.solution
        MoreDetails   = $_.plugin.see_also   
        Host          = $_.asset.netbios_name
        IPv4          = $_.asset.ipv4
        FQDN          = $_.asset.fqdn
        FirstSeen     = $_.first_found
        LastSeen      = $_.last_found
        State         = $_.state
    }
}

# --- Map CVE details for reporting later ---
$cveDetails = @{}
foreach ($v in $flat) {
    if ($v.CVE) {
        $v.CVE.Split(',') | ForEach-Object {
            $cve = $_.Trim()
            if (-not $cveDetails.ContainsKey($cve)) {
                $cveDetails[$cve] = [PSCustomObject]@{
                    Description = $v.Description
                    Solution    = $v.Solution
                    Severity    = $v.Severity
                    PluginName  = $v.PluginName
                }
            }
        }
    }
}

$flat | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $csvPath
Write-Log "Saved CSV to $csvPath"
Write-Log "✅ Tenable export complete — $($allVulns.Count) vulnerabilities."

# =====================================================
# STEP 2: Action1 Setup
# =====================================================

Write-Log "Configuring Action1 environment..."

$ModuleName = 'PSAction1'
if (-not (Get-InstalledModule -Name $ModuleName -ErrorAction SilentlyContinue)) {
    Write-Log "Installing $ModuleName..."
    Install-Module -Name $ModuleName -Force
} else {
    Write-Log "$ModuleName already installed."
}

Set-Action1Credentials -APIKey $Action1APIKey -Secret $Action1APISecret
Set-Action1DefaultOrg -Org_ID $Action1OrgID
Set-Action1Region -Region $Action1Region
Set-Action1Debug $false
Set-Action1Interactive $false

# =====================================================
# STEP 3: Compare Endpoints & Build CVE Map
# =====================================================

Write-Log "Retrieving Action1 endpoint list..."

try {
    $endpointResponse = Get-Action1 Endpoints
    $a1eps = $endpointResponse | Select-Object -ExpandProperty Name
    Write-Log "Retrieved $($a1eps.Count) Action1 endpoints."
} catch {
    Write-Log "Error retrieving endpoints from Action1: $($_.Exception.Message)" "ERROR"
    exit 1
}

$UnknownEndpoints = @()
$eps = @{}

Import-Csv -Path $csvPath | ForEach-Object {
    $epRaw = $_."Host"
    if (-not $epRaw) { return }

    $ep = ($epRaw -split '[\\.\\]')[0]
    $cveList = $_."CVE"

    if (-not $a1eps.Contains($ep)) {
        if ($UnknownEndpoints -notcontains $ep) {
            $UnknownEndpoints += $ep
            Write-Host "⚠️ Endpoint $ep not found in Action1."
        }
        return
    }

    if ([String]::IsNullOrEmpty($cveList)) {
        Write-Host "ℹ️ Endpoint $ep has no CVEs in this row."
        return
    }

    if ($eps.ContainsKey($ep)) {
        $eps[$ep] += "$cveList,"
    } else {
        $eps[$ep] = "$cveList,"
    }

    Write-Host "✅ Added CVEs for endpoint ${ep}: ${cveList}"
}

Write-Host "✅ Populated $($eps.Keys.Count) endpoints with CVEs."

# =====================================================
# STEP 4: Build CVE Lists & Remediation
# =====================================================

$cves = @{}
$cvesforremediation = @()
$cveswithnopatch = @()
$cvesnotrecognized = @()
$foundcve = @{}
$totaltime = 0

Write-Log "Fetching Action1 vulnerability catalog..."
Get-Action1 Vulnerabilities | ForEach-Object {
    $cveId = $_.cve_id
    $hasUpdates = $false
    foreach ($softwareItem in $_.software) {
        if ($softwareItem.available_updates -and $softwareItem.available_updates.Count -gt 0) {
            $hasUpdates = $true
            break
        }
    }
    $cves[$cveId] = $hasUpdates
}

$group = Get-Action1 Settings -For EndpointGroup
$group.name = "Remediation for $(Get-Date -Format 'yyyyMMdd_HHmmss')"
$remediation = Get-Action1 Settings -For DeferredRemediation

$count = 0; $nocount = 0

foreach ($ep in $eps.Keys) {
    $group.AddIncludeFilter('name', $ep)
    $sw = [Diagnostics.Stopwatch]::StartNew()

    $eps[$ep].Split(',') | ForEach-Object {
        $cve = $_.Trim()
        if (-not $cve) { return }

        if ($cves.ContainsKey($cve)) {
            if ($cves[$cve]) {
                if ($foundcve.ContainsKey($cve)) {
                    $foundcve[$cve] += 1
                    $nocount++
                } else {
                    $foundcve[$cve] = 1
                    $remediation.AddCVE($cve)
                    $cvesforremediation += $cve
                    $count++
                }
            } else {
                $cveswithnopatch += $cve
            }
        } else {
            $cvesnotrecognized += $cve
        }
    }

    $sw.Stop()
    $totaltime += $sw.Elapsed.TotalSeconds
}

if ($count -gt 0) {
#    $groupObj = New-Action1 EndpointGroup -Data $group
#    $remediation.AddEndpointGroup($groupObj.id)
#    Write-Host "`nRemediation created with $count CVEs (skipped $nocount duplicate CVEs)."
#    New-Action1 DeferredRemediation -Data $remediation
} else {
    Write-Host "`nNo CVEs matched for remediation."
}

Write-Host "`nProcessing all endpoints required $([math]::Round($totaltime,2)) seconds"

# =====================================================
# STEP 5: Import Assets to Tenable
# =====================================================


Write-Log "Starting asset sync: comparing Action1 and Tenable assets..."

# -------------------------------
# 1️ Retrieve all Action1 assets
# -------------------------------
Write-Log "Retrieving all Action1 endpoints..."
$action1Assets = $endpointResponse | Select-Object device_name, address, OS, Mac

if (-not $action1Assets) {
    Write-Log "No Action1 assets found — skipping sync."
    return
}

$action1Assets = $action1Assets | Where-Object { $_.device_name -and $_.device_name.Trim() -ne "" }
Write-Log "Retrieved $($action1Assets.Count) Action1 assets."

# -------------------------------
# 2️ Export all Tenable assets
# -------------------------------
Write-Log "Requesting Tenable asset export job..."
$exportUri = "$TenableApiBase/assets/v2/export"
$exportBody = @{chunk_size = 5000 } | ConvertTo-Json
$exportResp = Invoke-RestMethod -Uri $exportUri -Method POST -Headers $Headers -Body $exportBody -ContentType "application/json"
$exportUuid = $exportResp.export_uuid

Write-Log "Tenable asset export job started: $exportUuid"
$statusUri = "$TenableApiBase/assets/export/$exportUuid/status"

do {
    Start-Sleep -Seconds 5
    $statusResp = Invoke-RestMethod -Uri $statusUri -Method GET -Headers $Headers
    Write-Log "Tenable export job status: $($statusResp.status)"
} while ($statusResp.status -ne "FINISHED")

# -------------------------------
# 3️ Download Tenable asset chunks
# -------------------------------
$chunks = $statusResp.chunks_available
$tenableAssets = @()

foreach ($chunk in $chunks) {
    $chunkUri = "$TenableApiBase/assets/export/$exportUuid/chunks/$chunk"
    $chunkData = Invoke-RestMethod -Uri $chunkUri -Method GET -Headers $Headers
    if ($chunkData -is [System.Collections.IEnumerable]) {
        $tenableAssets += $chunkData
    }
    else {
        # If it’s a single object, wrap it and append
        $tenableAssets += ,$chunkData
    }
}

Write-Log "Retrieved $($tenableAssets.Count) Tenable assets."

# -------------------------------
# 4️ Build lookup from Tenable
# -------------------------------
$tenableLookup = @{}
foreach ($asset in $tenableAssets) {
    $name = $null
    $ip   = $null
    $mac  = $null
    $os   = $null

    if ($asset -and $asset.network.netbios_names) {
        $name = $asset.network.netbios_names.ToLower()
    }
    if ($asset -and $asset.network.ipv4s -and $asset.network.ipv4s.Count -gt 0) {
        $ip = $asset.network.ipv4s[0]
    }
    if ($asset -and $asset.network.mac_addresses -and $asset.network.mac_addresses.Count -gt 0) {
        $mac = $asset.network.mac_addresses[0]
    }
    if ($asset -and $asset.operating_system -and $asset.operating_system.Count -gt 0) {
        $os = $asset.operating_system[0]
    }

    if ($name) {
        $tenableLookup[$name] = @{
            ipv4 = $ip
            mac  = $mac
            os   = $os
        }
    }
}


# -------------------------------
# 5️ Identify missing assets (Action1 not in Tenable)
# -------------------------------
Write-Log "Finding Action1 endpoints not in Tenable..."
# Initialize the missing asset arrays safely
$missingFromTenable = @()
$missingFromAction1 = @()


foreach ($a1 in $action1Assets) {
    $name = $a1.device_name.ToLower()
    $ip   = $a1.address
    $mac  = $a1.Mac
    $os   = $a1.OS

    $match = $false
    if ($tenableLookup.ContainsKey($name)) {
        $match = $true
    } elseif ($tenableLookup.Values | Where-Object { $_.ipv4 -eq $ip -or $_.mac -eq $mac }) {
        $match = $true
    }

    if (-not $match) {
        $missingFromTenable  += [PSCustomObject]@{
            NetBIOS = $a1.device_name
            IPv4    = $ip
            MAC     = $mac
            OS      = $os
        }
    }
}


$missingFromTenablePath = Join-Path $OutputDirectory "MissingAssets_FromTenable.csv"
$missingFromTenable | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $missingFromTenablePath
$attachments += $missingFromTenablePath
Write-Log "Found $($missingFromTenable.Count) Action1 assets missing from Tenable."
Write-Log "Exported missing Action1 assets to: $missingFromTenablePath"

# -------------------------------
# 6️ Identify missing assets (Tenable not in Action1)
# -------------------------------
Write-Log "Finding Tenable assets not in Action1..."
$missingFromAction1 = @()

foreach ($tenable in $tenableLookup.Keys) {
    $found = $false
    if ($action1Assets.device_name -contains $tenable) {
        $found = $true
    } else {
        # Match by IP or MAC
        $tdata = $tenableLookup[$tenable]
        if ($action1Assets | Where-Object { $_.address -eq $tdata.ipv4 -or $_.Mac -eq $tdata.mac }) {
            $found = $true
        }
    }

    if (-not $found) {
        $data = $tenableLookup[$tenable]
        $missingFromAction1 += [PSCustomObject]@{
            NetBIOS = $tenable
            IPv4    = $data.ipv4
            MAC     = $data.mac
            OS      = $data.os
        }
    }
}

$missingFromAction1Path = Join-Path $OutputDirectory "MissingAssets_FromAction1.csv"
$missingFromAction1 | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $missingFromAction1Path
$attachments += $missingFromAction1Path
Write-Log "Found $($missingFromAction1.Count) Tenable assets missing from Action1."
Write-Log "Exported missing Tenable assets to: $missingFromAction1Path"

# -------------------------------
# 7️ Upload missing Action1 assets to Tenable
# -------------------------------
if ($missingFromTenable.Count -gt 0) {
    Write-Host "`n🆕 Uploading missing Action1 assets to Tenable..." -ForegroundColor Cyan

    $assetsToUpload = @()
    foreach ($asset in $missingFromTenable) {
        $assetObj = @{
            netbios_name      = $asset.NetBIOS
            ipv4              = @($asset.IPv4)
            mac_address       = @($asset.MAC)
            operating_system  = @($asset.OS)
        }
        $assetsToUpload += $assetObj
    }

    $importUri = "$TenableApiBase/import/assets"
    $importBody = @{ assets = $assetsToUpload; source = "Action1_Sync" } | ConvertTo-Json -Depth 6

    try {
        $response = Invoke-RestMethod -Uri $importUri -Method POST -Headers $Headers -Body $importBody -ContentType "application/json"
        Write-Host "✅ Successfully imported $($missingFromTenable.Count) new assets into Tenable." -ForegroundColor Green
    }
    catch {
        Write-Host "❌ Failed to upload assets to Tenable: $($_.Exception.Message)" -ForegroundColor Red
    }
}
else {
    Write-Log "No missing Action1 assets to import."
}

# =====================================================
# STEP 6: Reporting
# =====================================================

Write-Host "`n===================================="
Write-Host "📊  Endpoint and CVE Report"
Write-Host "===================================="

$csvEndpoints = $eps.Keys
$A1NotInCSV = $a1eps | Where-Object { $_ -notin $csvEndpoints }
$uniqueUnknown = $UnknownEndpoints | Sort-Object -Unique

Write-Host "`nTotal Action1 endpoints not found in $($VulnerabilityManager): $($A1NotInCSV.Count)"
if ($A1NotInCSV.Count -gt 0) { $A1NotInCSV | ForEach-Object { Write-Host " - $_" } }

Write-Host "`nTotal $VulnerabilityManager endpoints not found in Action1: $($uniqueUnknown.Count)"
if ($uniqueUnknown.Count -gt 0) { $uniqueUnknown | ForEach-Object { Write-Host " - $_" } }

Show-CVEReport -Title "$VulnerabilityManager CVEs for Remediation" `
               -CVEList $cvesforremediation `
               -CVEDetails $cveDetails `
               -OutputFilePrefix "Remediation" `
               -OutputDir $OutputDirectory

Show-CVEReport -Title "$VulnerabilityManager CVEs with no patch available" `
               -CVEList $cveswithnopatch `
               -CVEDetails $cveDetails `
               -OutputFilePrefix "NoPatch" `
               -OutputDir $OutputDirectory

Show-CVEReport -Title "$VulnerabilityManager CVEs not recognized by Action1" `
               -CVEList $cvesnotrecognized `
               -CVEDetails $cveDetails `
               -OutputFilePrefix "NotRecognized" `
               -OutputDir $OutputDirectory

Write-Host "`n====================================`n"

# =====================================================
# STEP 7: Optional Email Results
# =====================================================

if ($SendEmail) {
    if ($SmtpServer -and $MailTo -and $MailFrom) {
        Write-Log "Email flag detected — preparing to send reports."

        # Attach any CSVs created during the run
        Write-Log "Preparing to send $($attachments.Count) attachments..."
        $body = @"
Hello,

Attached are the latest Tenable → Action1 vulnerability reports.

Generated on: $(Get-Date)
Output directory: $OutputDirectory

Regards,
Action1 Automation Script
"@

        Send-EmailReport `
            -SmtpServer $SmtpServer `
            -SmtpPort $SmtpPort `
            -SmtpUser $SmtpUser `
            -SmtpPassword $SmtpPassword `
            -MailFrom $MailFrom `
            -MailTo $MailTo `
            -MailSubject $MailSubject `
            -MailBody $body `
            -Attachments $attachments `
            -UseSsl:$UseSsl
    } else {
        Write-Log "SMTP or email parameters not fully configured — skipping email delivery."
    }
} else {
    Write-Log "Email flag not set — skipping email delivery."
}
