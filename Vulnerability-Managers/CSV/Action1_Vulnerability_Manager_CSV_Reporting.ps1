# Name: Action1_Vulnerability_Manager_CSV_Reporting.ps1
# Description: This script will take in a CSV file from a Vulnerability Manager as input and correlate the endpoints and vulnerabilities within the CSV with the Action1 API.  Reports will be created and provided to the user as output or through email.
# Copyright (C) 2024 Action1 Corporation
# Documentation: https://github.com/Action1Corp/Integrations/blob/main/Vulnerability-Managers/CSV/README.md

# Use Action1 Roadmap system (https://roadmap.action1.com/) to submit feedback or enhancement requests.

# WARNING: Carefully study the provided scripts and components before using them. Test in your non-production lab first.

# LIMITATION OF LIABILITY. IN NO EVENT SHALL ACTION1 OR ITS SUPPLIERS, OR THEIR RESPECTIVE
# OFFICERS, DIRECTORS, EMPLOYEES, OR AGENTS BE LIABLE WITH RESPECT TO THE WEBSITE OR
# THE COMPONENTS OR THE SERVICES UNDER ANY CONTRACT, NEGLIGENCE, TORT, STRICT
# LIABILITY OR OTHER LEGAL OR EQUITABLE THEORY (I)FOR ANY AMOUNT IN THE AGGREGATE IN
# EXCESS OF THE GREATER OF FEES PAID BY YOU THEREFOR OR $100; (II) FOR ANY INDIRECT,
# INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES OF ANY KIND WHATSOEVER; (III) FOR
# DATA LOSS OR COST OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; OR (IV) FOR ANY
# MATTER BEYOND ACTION1'S REASONABLE CONTROL. SOME STATES DO NOT ALLOW THE
# EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE
# LIMITATIONS AND EXCLUSIONS MAY NOT APPLY TO YOU.

param(
    # --- Input File ---
    [string]$InputCSV,
    [string]$CSVHostHeader = "Hostname",
    [string]$CSVCVEHeader = "CVEID",

    # --- Output Directory ---
    [string]$OutputDirectory = "C:\Action1\CSV-Output",

    # --- Action1 Configuration ---
    [string]$Action1APIKey,
    [string]$Action1APISecret,
    [string]$Action1OrgID,
    [string]$Action1Region = "NorthAmerica",
    
    # --- SMTP / Email Settings ---
    [switch]$SendEmail = $false,
    [string]$SmtpServer,
    [int]$SmtpPort = 587,
    [string]$SmtpUser,
    [string]$SmtpPassword,
    [string]$MailFrom,
    [string]$MailTo,
    [string]$MailSubject = "Action1 Vulnerability Reports",
    [switch]$UseSsl = $true
)


# =====================================================
# UTILITIES
# =====================================================

function Write-Log {
    param($Message, $Level = "INFO")
    $ts = (Get-Date).ToString("s")
    Write-Host "[$ts][$Level] $Message"
}

function Show-CVEReport {
    param(
        [string]$Title,
        [array]$CVEList,
        [hashtable]$CVEDetails,
        [string]$OutputDir = "."
    )

    if (-not (Test-Path $OutputDir)) {
        New-Item -ItemType Directory -Force -Path $OutputDir | Out-Null
    }

    Write-Host "`n📋 $Title" -ForegroundColor Cyan
    Write-Host "----------------------------------------"

    $reportData = @()

    foreach ($cve in ($CVEList | Sort-Object -Unique)) {
        if ($CVEDetails.ContainsKey($cve)) {
            $info = $CVEDetails[$cve]
            $reportData += [PSCustomObject]@{
                CVE         = $cve
                Severity    = $info.Severity
                Plugin      = $info.PluginName
                Description = $info.Description
                Solution    = $info.Solution
            }
        }
        else {
            $reportData += [PSCustomObject]@{
                CVE         = $cve
                Severity    = "Unknown"
                Plugin      = "(Not found)"
                Description = "(No description available)"
                Solution    = "(No solution available)"
            }
        }
    }

    $reportPath = Join-Path $OutputDir "$($Title.Replace(' ', '_')).csv"
    $reportData | Export-Csv -Path $reportPath -Encoding UTF8 -NoTypeInformation

    Write-Host "Exported: $reportPath"
    $script:attachments += $reportPath
}

function Send-EmailReport {
    param(
        [string]$SmtpServer,
        [int]$SmtpPort,
        [string]$SmtpUser,
        [string]$SmtpPassword,
        [string]$MailFrom,
        [string]$MailTo,
        [string]$MailSubject,
        [string]$MailBody,
        [string[]]$Attachments,
        [switch]$UseSsl
    )

    Write-Log "Preparing email report..."

    try {
        $smtpClient = New-Object System.Net.Mail.SmtpClient($SmtpServer, $SmtpPort)
        $smtpClient.EnableSsl = $UseSsl
        if ($SmtpUser -and $SmtpPassword) {
            $smtpClient.Credentials = New-Object System.Net.NetworkCredential($SmtpUser, $SmtpPassword)
        } else {
            $smtpClient.UseDefaultCredentials = $true
        }

        $mailMessage = New-Object System.Net.Mail.MailMessage
        $mailMessage.From = $MailFrom
        $MailTo.Split(',') | ForEach-Object { $mailMessage.To.Add($_.Trim()) }
        $mailMessage.Subject = $MailSubject
        $mailMessage.Body = $MailBody
        $mailMessage.IsBodyHtml = $false

        foreach ($file in $Attachments) {
            if (Test-Path $file) {
                Write-Log "Attaching file: $file"
                $attachment = New-Object System.Net.Mail.Attachment($file)
                $mailMessage.Attachments.Add($attachment)
            } else {
                Write-Log "Attachment not found: $file" "WARN"
            }
        }

        Write-Log "Sending email to $MailTo via $SmtpServer..."
        $smtpClient.Send($mailMessage)
        Write-Host "📧 Email sent successfully to $MailTo" -ForegroundColor Green
    } catch {
        Write-Host "❌ Failed to send email: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# INPUT VALIDATION & SETUP
# =====================================================

if (-not (Test-Path $InputCSV)) {
    Write-Log "CSV file not found: $InputCSV" "ERROR"
    exit 1
}

if (-not (Test-Path $OutputDirectory)) {
    New-Item -ItemType Directory -Force -Path $OutputDirectory | Out-Null
}

$attachments = @()

Write-Log "Loading CSV: $InputCSV"
$csv = Import-Csv $InputCSV

if (-not $csv) {
    Write-Log "CSV appears empty." "ERROR"
    exit
}

# =====================================================
# ACTION1 INITIALIZATION
# =====================================================

Write-Log "Initializing Action1..."

$ModuleName = "PSAction1"
if (-not (Get-InstalledModule -Name $ModuleName -ErrorAction SilentlyContinue)) {
    Install-Module -Name $ModuleName -Force
}

# Set credentials only if provided (avoid empty calls)
if ($Action1APIKey -and $Action1APISecret) {
    Set-Action1Credentials -APIKey $Action1APIKey -Secret $Action1APISecret
}
if ($Action1OrgID) { Set-Action1DefaultOrg -Org_ID $Action1OrgID }
Set-Action1Region -Region $Action1Region
Set-Action1Debug $false
Set-Action1Interactive $false

# =====================================================
# RETRIEVE ACTION1 ENDPOINTS & ASSETS
# =====================================================

Write-Log "Retrieving Action1 endpoints..."
try {
    $endpointResponse = Get-Action1 Endpoints
} catch {
    Write-Log "Failed to retrieve Action1 endpoints: $($_.Exception.Message)" "ERROR"
    exit 1
}

# endpointResponse may be objects with Name, device_name, address, OS, Mac — keep both Name list and full asset list
$a1eps = $endpointResponse | Select-Object -ExpandProperty Name
$action1Assets = $endpointResponse | Select-Object device_name, address, OS, Mac

Write-Log "Retrieved $($a1eps.Count) Action1 endpoints."

# =====================================================
# MAP CSV → ENDPOINTS & COLLECT CSV HOSTNAMES
# =====================================================

Write-Log "Processing CSV data to map endpoints and CVEs..."

$eps = @{}                # endpoint -> comma-separated CVEs
$UnknownEndpoints = @()   # CSV hosts not in Action1
$csvHosts = @()           # unique CSV hostnames (normalized)

foreach ($entry in $csv) {
    if (-not $entry.$CSVHostHeader) { continue }
    $raw = $entry.$CSVHostHeader.Trim()
    $ep = $raw.Split('.')[0].Trim()
    if (-not ($csvHosts -contains $ep)) {$csvHosts += $ep }

    $cve = $entry.$CSVCVEHeader
    if (-not $cve) { continue }
    $cve = $cve.Trim()

    if (-not $a1eps.Contains($ep)) {
        if ($UnknownEndpoints -notcontains $ep) { $UnknownEndpoints += $ep }
        continue
    }

    if ($eps.ContainsKey($ep)) { $eps[$ep] += "$cve," }
    else { $eps[$ep] = "$cve," }

    Write-Host "✅ Mapped CVE $cve to endpoint $ep"
}

Write-Log "Mapped CVEs for $($eps.Keys.Count) endpoints."
Write-Log "CSV contains $($csvHosts.Count) unique hostnames; $($UnknownEndpoints.Count) not found in Action1."

# =====================================================
# IDENTIFY MISSING ASSETS / ENDPOINT REPORTS
# =====================================================

Write-Log "Building missing-assets and endpoint reports..."

# 1) Action1 endpoints not present in CSV (Action1 -> CSV missing)
$action1NotInCSV = @()
foreach ($a in $action1Assets) {
    if (-not $a.device_name) { continue }
    $name = $a.device_name.Trim()
    if (-not ($csvHosts -contains $name)) {
        $action1NotInCSV += [PSCustomObject]@{
            NetBIOS = $a.device_name
            IPv4    = $a.address
            MAC     = $a.Mac
            OS      = $a.OS
        }
    }
}

$action1NotInCSVPath = Join-Path $OutputDirectory "Action1_Endpoints_Not_In_CSV.csv"
$action1NotInCSV | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $action1NotInCSVPath
$attachments += $action1NotInCSVPath
Write-Log "Action1 endpoints not in CSV: $($action1NotInCSV.Count). Exported to $action1NotInCSVPath"

# 2) CSV hosts not present in Action1 (CSV -> Action1 missing)
$csvHostsNotInAction1 = $csvHosts | Where-Object { $_ -notin $a1eps } | Sort-Object -Unique
$csvHostsNotInAction1Path = Join-Path $OutputDirectory "CSV_Hosts_Not_In_Action1.csv"
$csvHostsNotInAction1 | ForEach-Object { [PSCustomObject]@{ Hostname = $_ } } | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $csvHostsNotInAction1Path
$attachments += $csvHostsNotInAction1Path
Write-Log "CSV hosts not in Action1: $($csvHostsNotInAction1.Count). Exported to $csvHostsNotInAction1Path"

# Provide console summary
Write-Host "`nEndpoint sync summary:"
Write-Host " - Total Action1 endpoints: $($a1eps.Count)"
Write-Host " - Unique CSV hostnames:   $($csvHosts.Count)"
Write-Host " - CSV hosts missing in Action1: $($csvHostsNotInAction1.Count)"
Write-Host " - Action1 endpoints missing in CSV: $($action1NotInCSV.Count)"
if ($csvHostsNotInAction1.Count -gt 0) {
    Write-Host "`nCSV hosts not in Action1:"
    $csvHostsNotInAction1 | ForEach-Object { Write-Host " - $_" }
}
if ($action1NotInCSV.Count -gt 0) {
    Write-Host "`nSample Action1 endpoints not in CSV (first 10):"
    $action1NotInCSV | Select-Object -First 10 | Format-Table -AutoSize
}

# =====================================================
# GATHER ACTION1 CVE CATALOG
# =====================================================

Write-Log "Fetching Action1 vulnerability catalog..."

$cves = @{}               # CVE → HasPatch?
$cveDetails = @{}         # CVE → Description/Solution
$cvesforremediation = @()
$cveswithnopatch = @()
$cvesnotrecognized = @()
$foundcve = @{}

Get-Action1 Vulnerabilities | ForEach-Object {

    $cveId = $_.cve_id
    $hasUpdates = $false

    foreach ($softwareItem in $_.software) {
        if ($softwareItem.available_updates -and $softwareItem.available_updates.Count -gt 0) {
            $hasUpdates = $true
        }
    }

    $cves[$cveId] = $hasUpdates

    if (-not $cveDetails.ContainsKey($cveId)) {
        $cveDetails[$cveId] = [PSCustomObject]@{
            Description = $_.description
            Solution    = $_.solution
            Severity    = $_.severity
            PluginName  = "(N/A)"
        }
    }
}

# =====================================================
# BUILD REMEDIATION STRUCTURE
# =====================================================

Write-Log "Building remediation CVE lists..."

foreach ($ep in $eps.Keys) {

    $eps[$ep].Split(',') | ForEach-Object {
        $cve = $_.Trim()
        if (-not $cve) { return }

        if ($cves.ContainsKey($cve)) {
            if ($cves[$cve]) {
                if (-not $foundcve.ContainsKey($cve)) {
                    $foundcve[$cve] = 1
                    $cvesforremediation += $cve
                }
            }
            else { $cveswithnopatch += $cve }
        }
        else { $cvesnotrecognized += $cve }
    }
}

# =====================================================
# REPORTING SECTION (CVEs)
# =====================================================

Write-Host "`n===================================="
Write-Host "📊  CSV / Action1 Vulnerability Report"
Write-Host "===================================="

Show-CVEReport -Title "CVEs_for_Remediation" `
               -CVEList $cvesforremediation `
               -CVEDetails $cveDetails `
               -OutputDir $OutputDirectory

Show-CVEReport -Title "CVEs_with_No_Patch" `
               -CVEList $cveswithnopatch `
               -CVEDetails $cveDetails `
               -OutputDir $OutputDirectory

Show-CVEReport -Title "CVEs_Not_Recognized" `
               -CVEList $cvesnotrecognized `
               -CVEDetails $cveDetails `
               -OutputDir $OutputDirectory

# =====================================================
# OPTIONAL EMAIL
# =====================================================

if ($SendEmail) {
    $body = @"
Action1 Vulnerability & Endpoint Report

Generated: $(Get-Date)
Output Directory: $OutputDirectory

Reports attached:
 - CVE tables
 - $action1NotInCSVPath (Action1 endpoints not in CSV)
 - $csvHostsNotInAction1Path (CSV hosts not in Action1)

"@
    Send-EmailReport `
        -SmtpServer $SmtpServer `
        -SmtpPort $SmtpPort `
        -SmtpUser $SmtpUser `
        -SmtpPassword $SmtpPassword `
        -MailFrom $MailFrom `
        -MailTo $MailTo `
        -MailSubject $MailSubject `
        -MailBody $body `
        -Attachments $attachments `
        -UseSsl:$UseSsl
} else {
    Write-Log "Email flag not set — skipping email delivery."
}

Write-Log "Completed."
